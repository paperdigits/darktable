<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE dita
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "../../../../dtd/ditabase.dtd">
<dita>
   <topic xml:lang="en-us" id="special_topics_chapter">
      <title>Special topics</title>
      
      <prolog>
         <metadata>
            <keywords>
               <keyword>topics</keyword>
               <keyword>special</keyword>
            </keywords>
            
            
         </metadata>
         
      </prolog>
      <body>
         <p>
    This chapter touches several technical topics which might help you to get darktable running
    on specific hardware or optimize its performance. A lot of additional technical background
    information and many tips and tricks are also covered in an extensive blog section that you
    can find on our <xref href="https://www.darktable.org" format="html" scope="external">homepage</xref>.
  </p>
         <fig id="fig_zz4_ryb_flb">
            <title>The darktable blog</title>
            <image href="../images/darktable_blog.png" placement="break" id="image_a1p_ryb_flb"/>
         </fig>
      </body>
      <topic xml:lang="en-us" id="darktable_and_memory">
         <title>darktable and memory</title>
         
         <prolog>
            <metadata><keywords>
                  <indexterm>memory setup</indexterm>
               </keywords></metadata>
            
         </prolog>
         <body>
            <p>
    darktable's memory requirements are high. A simple calculation makes this clear. If you have
    a 20MPix image, darktable for precision reasons will store this internally as a 4 x 32-bit
    floating point cell for each pixel. Each full image of this size will need about 300MB of
    memory. As we want to process the image, we will at least need two buffers for each module
     – one for input and one for output. If we have a more complex module, its
    algorithm might additionally require several intermediate buffers of the same size. Without
    further optimization, anything between 600MB and 3GB would be needed only to store and
    process image data. On top we have darktable's code segment, the code and data of all
    dynamically linked system libraries, and not to forget further buffers where darktable
    stores intermediate images for quick access during interactive work (mip map cache). All in
    all, darktable would like to see a minimum of about 4GB to run happily.
  </p>
         </body>
         <topic xml:lang="en-us" id="darktable_and_memory_system">
            <title>Total system memory</title>
            <body>
               <p>
      From what I said before, it is evident that your computer needs a sane memory setup to
      properly run darktable. We suggest that you have a least 4GB of physical RAM plus 4 to 8GB
      of additional swap space installed. The latter is required, so that your system can swap
      out temporarily unneeded data to disk in order to free physical RAM.
    </p>
               <p>
      Theoretically, you could also run darktable with lower amounts of physical RAM and balance
      this with enough swap space. However, you should be prepared that your system could then
      heavily <q>thrash</q>, as it reads or writes data pages to and from the hard disk.
      We have positive reports that this functions well for several users, but it still might
      get extremely slow for others...
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_memory_space">
            <title>Available address space</title>
            <body>
               <p>
      Besides the total amount of system memory there is another limiting factor: the available
      address space of your hardware architecture. How much memory can be addressed by a process
      depends on the number of address bits your CPU offers. For a CPU with 32-bit address
      registers, this is 2^32 bytes, which makes a total of 4GB. This is the absolute upper
      limit of memory that can be used by a process and it constitutes a tight situation for
      darktable as we have seen above.
    </p>
               <p>
      darktable's escape route is called tiling. Instead of processing an image in one big
      chunk, we split the image into smaller parts for every processing step (module). This will
      still require one full input and output buffer, but intermediate buffers can be made small
      enough to have everything fit into the hardware limits.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_memory_fragmentation">
            <title>Memory fragmentation</title>
            <body>
               <p>
      Unfortunately this is not the full story yet. There is an effect called memory
      fragmentation, which can and will hit software that needs to do extensive memory
      management. If such a program allocates 5 times 300MB at a time and frees it again, that
      memory should normally be available for one big 1.5GB allocation afterwards. This however
      is often not the case. The system's memory allocator may no longer see this area as one
      contiguous 1.5GB block but as a row of 300MB areas. If there is no other free area of
      1.5GB available, the allocation would fail. During a program run this mechanism will take
      away more and more of the larger memory blocks in favor of smaller ones. darktable 2.0 mip
      map cache allocates several small memory blocks per each thumbnail, so this problem is
      even bigger. For this reason, as of darktable 2.0, 32-bit support is soft-deprecated.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_memory_limitations">
            <title>Further limitations</title>
            <body>
               <p>
      As if this were not challenging enough, there are further things that might limit your
      access to memory. On some older boards you need to activate BIOS option <q>memory
      remapping</q> in order to have all physically installed memory enabled. In addition if
      you are on a 32-bit OS you will probably need a kernel version that has <q>Physical
      Address Extension</q> (PAE) enabled. This is often but not always the case for Linux.
      Many distributions deliver different kernels, some with and some without PAE activated;
      you need to choose the right one. To check if the system is setup correctly, use the
      command <q>free</q> in a terminal and examine the output. If the output reports
      less RAM than you have installed, you have an issue needing correction; for example you
      have 4GB on your board, but your kernel is only seeing 3GB or less. You need to consult
      your BIOS manual and the information about your Linux variant for further help.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_memory_32bit">
            <title>Setting up darktable on 32-bit systems</title>
            
            <prolog>
               <metadata><keywords>
                     <indexterm>memory setup<indexterm>32-bit systems</indexterm></indexterm>
                     <indexterm>tiling</indexterm>
                  </keywords></metadata>
               
            </prolog>
            <body>
               <p>
      As we've seen 32-bit systems are difficult environments for darktable. Still some users
      are running darktable on them, if the basic requirements in terms of total system memory
      and the topics mentioned in the paragraphs above are addressed properly.
    </p>
               <p>
      There are several adjustment parameters to get it running. If you install fresh, darktable
      will detect your system and set conservative values by default. However, if you upgrade
      darktable from an older version (e.g. coming from 0.9.3 and going to 1.0), chances are you
      have unfavorable settings in your preferences. The consequences might be darktable
      aborting due to allocation failures or – very typically – darktable
      not being able to properly import a new film roll. As a frequent symptom you get skulls
      displayed instead of thumbs for many of your pictures.
    </p>
               <p>
      If this is the case, take a minute to optimize the preference settings in this case. You
      will find them under <q>core options</q> (<xref href="core_options"/>) in
      darktable's preference dialog. You should also find these parameters as configuration
      variables in $HOME/.config/darktable/darktablerc and edit them there.
    </p>
               <p>
      Here is a short explanation of the relevant parameters and their proposed settings:
      <dl>
                     <dlentry>
                        <dt>number of background threads</dt>
                        <dd>
                           <p>
            This parameter defines the maximum number of threads that are allowed in parallel
            when importing film rolls or doing other background stuff. For obvious reasons on
            32-bit systems you can only have one thread eating resources at a time. So you need
            set this parameter to 1; anything higher will kill you.
          </p>
                        </dd>
                     </dlentry>
                     <dlentry>
                        <dt>host memory limit (in MB) for tiling</dt>
                        <dd>
                           <p>
            This parameter tells darktable how much memory (in MB) it should assume is available
            to store image buffers during module operations. If an image can not be processed
            within these limits in one chunk, tiling will take over and process the image in
            several parts, one after the other. Set this to the lowest possible value of 500 as
            a starting point. You might experiment later whether you can increase it a bit in
            order to reduce the overhead of tiling.
          </p>
                        </dd>
                     </dlentry>
                     <dlentry>
                        <dt>minimum amount of memory (in MB) for a single buffer in tiling</dt>
                        <dd>
                           <p>
            This is a second parameter that controls tiling. It sets a lower limit for the size
            of intermediate image buffers in megabytes. The parameter is needed to avoid
            excessive tiling in some cases (for some modules). Set this parameter to a low value
            of 8. You might tentatively increase it to 16 later.
          </p>
                        </dd>
                     </dlentry>
                     <dlentry>
                        <dt>memory in megabytes to use for thumbnail cache</dt>
                        <dd>
                           <p>
            This controls how many thumbnails (or mip maps) can be stored in memory at a time.
            As a starting point set this to something like 256MB. Since darktable 2.0, the cache
            does allocate a few small buffers per each thumbnail in cache, thus causing
            significant memory fragmentation. As explained before, this poses a problem for
            32-bit systems. For this reason, as of darktable 2.0, 32-bit support is
            soft-deprecated.
          </p>
                        </dd>
                     </dlentry>
                  </dl>
               </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_memory_64bit">
            <title>darktable on 64-bit systems</title>
            
            <prolog>
               <metadata><keywords>
                     <indexterm>memory setup<indexterm>64-bit systems</indexterm></indexterm>
                  </keywords></metadata>
               
            </prolog>
            <body>
               <p>
      There's not much to be said here. Of course also 64-bit systems require a sufficient
      amount of main memory, so the 4GB plus swap recommendation holds true. On the other hand,
      64-bit architectures do not suffer from the specific 32-bit limitations like small address
      space and fragmentation madness.
    </p>
               <p>
      Most modern Intel or AMD 64-bit CPUs will have available address space in the range of
      several Terabytes. The word <q>modern</q> is relative in this context: all AMD and
      Intel CPUs introduced since 2003 and 2004, respectively, offer a 64-bit mode. Linux 64-bit
      has been available for many years.
    </p>
               <p>
      All relevant Linux distributions give you the choice to install a 32-bit or a 64-bit
      version with no added costs. You can even run old 32-bit binaries on a 64-bit Linux. The
      only thing you need to do: invest some time into the migration. In the end we strongly
      recommend moving to a 64-bit version of Linux. There really is no reason not to upgrade to
      64-bit.
    </p>
               <p>
      On a 64-bit system you can safely leave the tiling related configuration parameters at
      their defaults: <q>host memory limit (in MB) for tiling</q> should have a value of
      1500 and <q>minimum amount of memory (in MB) for a single buffer in tiling</q>
      should be set to 16. In case you are migrating from a 32-bit to a 64-bit system you will
      need to check these settings and manually change them if needed in darktable's preference
      dialog.
    </p>
               <p>
      Typically there is no need to restrict oneself in the number of background threads on a
      64-bit system. On a multi-processor system a number of two to eight threads can speed up
      thumbnail generation considerably versus only one thread. The reason is not so much taking
      maximum advantage of all your CPU cores – darktable's pixelpipe anyhow uses all
      of them in parallel – but hiding I/O latency.
    </p>
               <p> One exception is worth to be mentioned. If you use darktable to process
                     <indexterm>stitched panoramas</indexterm>, e.g. TIFFs as generated by Hugin,
                  these images can reach considerable sizes. Each background thread needs to
                  allocate enough memory to keep one full image plus intermediates and output in its
                  buffers. This may quickly run even a well equipped 64-bit system out of memory. In
                  that case lower the number of background threads to only one. </p>
            </body>
            
         </topic>
      </topic>
      <topic xml:lang="en-us" id="darktable_and_opencl">
         <title>darktable and OpenCL</title>
         
         <prolog>
            <metadata><keywords>
                  <indexterm>OpenCL</indexterm>
                  <indexterm>GPU computing</indexterm>
               </keywords></metadata>
            
         </prolog>
         <body>
            <p>
    darktable can use GPU acceleration via OpenCL to improve performance.
  </p>
         </body>
         <topic xml:lang="en-us" id="darktable_and_opencl_background">
            <title>The background</title>
            <body>
               <p>
      Processing high resolution images is a demanding task needing a modern computer. Both in
      terms of memory requirements and in terms of CPU power, getting the best out of a typical
      15, 20 or 25 Megapixel image can quickly bring your computer to its limits.
    </p>
               <p>
      darktable's requirements are no exception. Our decision to not compromise processing
      quality, has led to all calculations being done on 4 x 32bit floating point numbers. This
      is slower than <q>ordinary</q> 8 or 16bit integer algebra, but eliminates all
      problems of tonal breaks or loss of information.
    </p>
               <p>
      A lot of hand optimization has been invested to make darktable as fast as possible. If you
      run a current version of darktable on a modern computer, you might not notice any
      <q>slowness</q>. However, there are conditions and certain modules where you will
      feel (or hear from the howling of your CPU fan) how much your poor multi-core processor
      has to struggle.
    </p>
               <p>
      That's where OpenCL comes in. OpenCL allows us to take advantage of the enormous power of
      modern graphics cards. Gamer's demand for high detailed 3D worlds in modern ego shooters
      has fostered GPU development. ATI, NVIDIA and Co had to put enormous processing power into
      their GPUs to meet these demands. The result is modern graphics cards with highly
      parallelized GPUs to quickly calculate surfaces and textures at high frame rates.
    </p>
               <p>
      You are not a gamer and you don't take advantage of that power? Well, then you should at
      least use it in darktable! For the task of highly parallel floating point calculations
      modern GPUs are much faster than CPUs. That is especially true, when you want to do the
      same few processing steps over millions of items. Typical use case: processing of
      megapixel images.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_working">
            <title>How OpenCL works</title>
            <body>
               <p>
      As you can imagine, hardware architectures of GPUs can vary significantly. There are
      different manufacturers, and even different generations of GPUs from the same manufacturer
      may differ. At the same time GPU manufacturers don't normally disclose all hardware
      details of their products to the public. One of the known consequences is the need to use
      proprietary drivers under Linux, if you want to take full advantage of your graphics card.
    </p>
               <p>
      Fortunately an industry consortium lead by The Khronos Group has developed an open,
      standardized interface called OpenCL. It allows the use of your GPU as a numerical
      processing device. OpenCL offers a C99-like programming language with a strong focus on
      parallel computing. An application that wants to use OpenCL will need OpenCL source code
      that it hands over to a hardware specific OpenCL compiler at run-time. This way the
      application can use OpenCL on different GPU architectures (even at the same time). All
      hardware <q>secrets</q> are hidden in this compiler and are normally not visible
      to the user (or the application). The compiled OpenCL code is loaded onto your GPU
      and – with certain API calls – it is ready to do calculations for
      you.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_activation">
            <title>How to activate OpenCL in darktable</title>
            <body>
               <p>
      Using OpenCL in darktable requires that your PC is equipped with a suitable graphics card
      and that it has the required libraries in place. Namely modern graphics cards from NVIDIA
      and AMD come with full OpenCL support. The OpenCL compiler is normally shipped as part of
      the proprietary graphics driver; it is used as a dynamic library called
      <q>libOpenCL.so</q>. This library must be in a folder where it is found by your
      system's dynamic linker.
    </p>
               <p>
      When darktable starts, it will first try to find and load libOpenCL.so and – on
      success – check if the available graphics card comes with OpenCL support. A
      sufficient amount of graphics memory (1GB+) needs to be available to take advantage of the
      GPU. If that is OK, darktable tries to setup its OpenCL environment: a processing context
      needs to be initialized, a calculation pipeline to be started, OpenCL source code files
      (extension is .cl) need to be read and compiled and the included routines (called OpenCL
      kernels) need to be prepared for darktable's modules. If all that is done, the preparation
      is finished.
    </p>
               <p>
      Per default OpenCL support is activated in darktable if all the above steps were
      successful. If you want to de-activate it you can do so in <q>core options</q>
      (<xref href="core_options"/>) by unchecking <q>activate opencl support</q>.
      This configuration parameter also tells you if OpenCL initialization failed: it is greyed
      out in that case.
    </p>
               <p>
      You can at any time switch OpenCL support off and on; this will happen immediately.
      Depending on the type of modules you are using, you will notice the effect as a general
      speed-up during interactive work and during export. Most modules in darktable can take
      advantage of OpenCL but not all modules are demanding enough to make a noticeable
      difference. In order to feel a real difference, take modules like
      <xref href="shadows_and_hightlights">
                     <i>shadows and highlights</i>
                  </xref>,
      <xref href="sharpen">
                     <i>sharpen</i>
                  </xref>,
      <xref href="lowpass">
                     <i>lowpass</i>
                  </xref>,
      <xref href="highpass">
                     <i>highpass</i>
                  </xref> or even more extreme
      <xref href="equalizer">
                     <i>equalizer</i>
                  </xref> and
      <xref href="profiled_denoise">
                     <i>profiled denoise</i>
                  </xref>.
    </p>
               <p>
      If you are interested in profiling figures, you can start darktable with command line
      parameters <q>-d opencl -d perf</q>. After each run of the pixelpipe you will get
      a detailed allocation of processing time to each module plus an even more fine grained
      profile for all used OpenCL kernels.
    </p>
               <p>
      Besides the speed-up you should not see any difference in the results between CPU and GPU
      processing. Except of rounding errors, the results are designed to be identical. If, for
      some reasons, darktable fails to properly finish a GPU calculation, it will normally
      notice and automatically (and transparently) fall back to CPU processing.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_system">
            <title>Setting up OpenCL on your system</title>
            <body>
               <p>
      The huge diversity of systems and the marked differences between OpenCL vendors and driver
      versions makes it impossible to give an comprehensive overview of how to setup OpenCL. We
      only can give you an example, in this case for NVIDIA driver version 331.89 on Ubuntu
      14.04. We hope that this will serve you as a first impression and will help to solve
      possible problems of your specific setup.
    </p>
               <p>
      The principle OpenCL function flow is like this:
    </p>
               <p>
      darktable -&gt; libOpenCL.so -&gt; libnvidia-opencl.so.1 -&gt; kernel driver module(s) -&gt; GPU
    </p>
               <p>
                  <ul>
                     <li>
                        <p>
          darktable dynamically loads <filepath>libOpenCL.so</filepath>, a system library which
          must be accessible to the system's dynamic loader (<filepath>ld.so</filepath>).
        </p>
                     </li>
                     <li>
                        <p>
                           <filepath>libOpenCL.so</filepath> will read the vendor specific information file
          (<filepath>/etc/OpenCL/vendors/nvidia.icd</filepath>) to find the library which
          contains the vendor specific OpenCL implementation.
        </p>
                     </li>
                     <li>
                        <p>
          The vendor specific OpenCL implementation comes as a library
          <filepath>libnvidia-opencl.so.1</filepath> (which in our case is a symbolic link to
          <filepath>libnvidia-opencl.so.331.89</filepath>).
        </p>
                     </li>
                     <li>
                        <p>
                           <filepath>libnvidia-opencl.so.1</filepath> needs to talk to the vendor specific kernel
          modules <filepath>nvidia</filepath> and <filepath>nvidia_uvm</filepath> via device
          special files <filepath>/dev/nvidia0</filepath>, <filepath>/dev/nvidiactl</filepath>,
          and <filepath>/dev/nvidia-uvm</filepath>.
        </p>
                     </li>
                  </ul>
               </p>
               <p>
      At system startup the required device special files (/dev/nvidia*) need to be created. If
      this does not happen on your system by default, the easiest way to set them up and make
      sure all modules are loaded is installing the <filepath>nvidia-modprobe</filepath> package
      (which, at the time of this writing, is only available for <q>utopic</q>, but
      works well with <q>trusty</q> and <q>Mint 17</q>). You can grab it at
      <xref href="http://packages.ubuntu.com/utopic/nvidia-modprobe"
                        format="html"
                        scope="external">this site</xref>.
    </p>
               <p>
      A user account which wants to make use of OpenCL from within darktable needs to have
      read-write access to NVIDIA's device special files. On some systems these files allow
      world read-write access by default, which avoids permission issues but might be debatable
      in terms of system security. Other systems restrict the access to a user group, e.g.
      <q>video</q>. In that case your user account has to be member of that group.
    </p>
               <p>
      To summarise, the packages which needed to be installed in this specific case were:
      <ul>
                     <li>
                        <p>
          nvidia-331 (331.89-0ubuntu1~xedgers14.04.2)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-331-dev (331.89-0ubuntu1~xedgers14.04.2)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-331-uvm (331.89-0ubuntu1~xedgers14.04.2)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-libopencl1-331 (331.89-0ubuntu1~xedgers14.04.2)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-modprobe (340.24-1)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-opencl-dev:amd64 (5.5.22-3ubuntu1)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-opencl-icd-331 (331.89-0ubuntu1~xedgers14.04.2)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-settings (340.24-0ubuntu1~xedgers14.04.1)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-settings-304 (340.24-0ubuntu1~xedgers14.04.1)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-libopencl1-331 (331.89-0ubuntu1~xedgers14.04.2)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-opencl-dev:amd64 (5.5.22-3ubuntu1)
        </p>
                     </li>
                     <li>
                        <p>
          nvidia-opencl-icd-331 (331.89-0ubuntu1~xedgers14.04.2)
        </p>
                     </li>
                     <li>
                        <p>
          opencl-headers (1.2-2013.10.23-1)
        </p>
                     </li>
                  </ul>
               </p>
               <p>
      The list of NVIDIA related kernel modules as reported by <filepath>lsmod</filepath> is:
    </p>
               <p>
                  <pre>nvidia
nvidia_uvm
</pre>
               </p>
               <p>
      The list of NVIDIA related device special files (<filepath>ls -l /dev/nvidia*</filepath>)
      should read like:
    </p>
               <p>
                  <pre>crw-rw-rw- 1 root root 195,   0 Jul 28 21:13 /dev/nvidia0
crw-rw-rw- 1 root root 195, 255 Jul 28 21:13 /dev/nvidiactl
crw-rw-rw- 1 root root 250,   0 Jul 28 21:13 /dev/nvidia-uvm
</pre>
               </p>
               <p>
      Beware that the major/minor numbers (e.g. 250/0 for <filepath>/dev/nvidia-uvm</filepath>
      in this example) may vary depending on your system.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_problems_solutions">
            <title>Possible problems and solutions</title>
            <body>
               <p>
      darktable will detect OpenCL run-time problems automatically. It will then reprocess
      everything on CPU; only speed is affected, the final result should not be endangered.
    </p>
               <p>
      There can be various reasons why OpenCL could fail during initialization phase. We depend
      on hardware requirements and on the presence of certain drivers and libraries. In addition
      all these have to fit in terms of maker model and revision number. If anything does not
      fit, e.g. your graphics driver (loaded as a kernel module) does not match the version of
      your libOpenCL.so, OpenCL support is likely not available.
    </p>
               <p>
      In that case, the best thing to do is start darktable from a console with
    </p>
               <pre>darktable -d opencl
</pre>
               <p>
      This will give additional debugging output about the initialization and use of OpenCL.
      First see if you find a line that starts with <q>[opencl_init] FINALLY ...</q>
      This should tell you, if OpenCL support is available for you or not. If initialization
      failed, look at the messages above for anything that reads like <q>could not be
      detected</q> or <q>could not be created</q>. Check if there is a hint about
      where it failed.
    </p>
               <p>
      Here are a few cases observed in the past:
    </p>
               <ul>
                  <li> darktable might tell you that no OpenCL aware graphics card is detected or
                     that the available memory on your GPU is too low and the device is discarded.
                     In that case you might need to buy a new card, if you really want OpenCL
                     support. </li>
                  <li> darktable might find your libOpenCL.so but then tell you that it couldn't get
                     a platform. NVIDIA drivers will often give error code -1001 in that case. This
                     happens because libOpenCL.so is only a wrapper library. For the real work
                     further libraries – specific to vendor, device and driver – need to be loaded.
                     This failed for some reason. There is a structure of files in /etc/OpenCL on
                     your system that libOpenCL.so consults to find these libraries. Check if you
                     find something fishy in there and try to fix it. Often the needed libraries
                     cannot be found by your system's dynamic loader. Giving full path names might
                     help. </li>
                  <li> darktable might also tell you that a context could not be created. This often
                     indicates a version mismatch between (loaded) graphics driver and libOpenCL.
                     Check if you have left-over kernel modules or graphics libraries of an older
                     install and take appropriate action. In doubt, make a clean reinstall of your
                     graphics driver. Sometimes, immediately after a driver update, the loaded
                     kernel driver does not match the newly installed libraries: reboot your system
                     in that case. </li>
                  <li> darktable might crash in very rare cases directly during startup. This can
                     happen if your OpenCL setup is completely broken or if driver/library contains
                     a severe bug. If you can't fix it, you can still use darktable with option
                        <q>--disable-opencl</q>, which will skip the entire OpenCL initialization
                     step. </li>
                  <li> darktable might fail to compile its OpenCL source files at run-time. In that
                     case you will get a number of error messages looking like typical compiler
                     errors. This could indicate an incompatibility between your OpenCL
                     implementation and our interpretation of the standard. In that case visit us in
                     IRC in #darktable on FreeNode or on the developers mailing list at
                     darktable-dev@lists.darktable.org and report the problem. Chances are good that
                     we can help you. Please also report if you see significant differences between
                     CPU and GPU processing of an image! </li>
               </ul>
               <p>
      There also exists a few on-CPU implementations of OpenCL. These come as drivers provided
      by INTEL or AMD. We observed that they do not give us any speed gain versus our
      hand-optimized CPU code. Therefore we simply discard these devices by default. This
      behavior can be changed by setting the configuration variable opencl_use_cpu_devices to
      TRUE.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_amd">
            <title>Setting up OpenCL for AMD/ATI devices</title>
            <body>
               <p>
      While NVIDIA devices and most modern AMD/ATI devices will most often run out of the box,
      there is more to do for older AMD/ATI graphics cards, namely those prior to the HD7xxx
      series. This starts with the fact that those devices will only report to darktable part of
      their total GPU memory. For a 1GB device this typically amounts to 512MB, a value which
      darktable in its standard configuration will refuse as not being sufficient for its tasks.
      Consequence: the device will not be used.
    </p>
               <p>
      On the web you might find as a tip to set environment variable GPU_MAX_HEAP_SIZE to a
      value of 100 in this case. Indeed this will cause the AMD/ATI driver to report the full
      installed memory to darktable. However, there is a problem. On many (most?) cards this
      will cause buffers to be allocated on your computer (host) not on the video card! In this
      case all memory accesses will need to go through the slow PCIe bus. This will cost you a
      factor of 10x or more in performance and will render OpenCL useless for you, especially
      when exporting files.
    </p>
               <p>
      Another environment variable which changes driver behavior is GPU_MAX_ALLOC_PERCENT. You
      could set this to 100 in order to allow memory allocations as high as 1GB on your AMD/ATI
      card. The problem is, this tends to cause darktable to crash sooner or later.
    </p>
               <p>
      Our recommendation is to leave these settings untouched. Often your card will be
      recognized with 512MB memory and a maximum allocation size of 128MB. There are three
      configuration parameter which you set in file $HOME/.config/darktable/darktablerc to get
      things running. Here are the details:
      <dl>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_memory_requirement</systemoutput>

                        </dt>
                        <dd>
                           <p>
            Set this parameter to 500 so that darktable will accept your 512MB graphics memory
            as being sufficient in memory.
          </p>
                        </dd>
                     </dlentry>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_memory_headroom</systemoutput>

                        </dt>
                        <dd>
                           <p>
            This parameter controls how much graphics memory (out of the reported one) darktable
            should leave untouched for driver and display use. As for AMD/ATI devices we anyhow
            only can get half of the available RAM it's safe to set this to zero. So all of the
            512MB can be used by darktable.
          </p>
                        </dd>
                     </dlentry>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_avoid_atomics</systemoutput>

                        </dt>
                        <dd>
                           <p>
            Atomic operations in OpenCL are a special way of data synchronization. They are only
            used in a few kernels. Unfortunately, some (most?) AMD/ATI devices are extremely
            slow in processing atomics. It's better to process the affected modules on CPU
            rather than accepting an ultra-slow GPU codepath. Set this parameter to TRUE if you
            experience slow processing of modules like
            <xref href="shadows_and_highlights">
                                 <i>shadows and
            highlights</i>
                              </xref>,
            <xref href="monochrome">
                                 <i>monochrome</i>
                              </xref>,
            <xref href="local_contrast">
                                 <i>local contrast</i>
                              </xref>, or
            <xref href="global_tonemap">
                                 <i>global tonemap</i>
                              </xref> or if you
            even get intermittent system freezes.
          </p>
                        </dd>
                     </dlentry>
                  </dl>
               </p>
               <p>
      These recommendations do not apply to the more recent Radeon HD7xxx series with GCN
      architecture. Besides being very fast in terms of GPU computing they normally run out of
      the box. You only might consider to try some of the performance optimization options which
      are described in the following section.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_optimization">
            <title>OpenCL performance optimization</title>
            <body>
               <p>
      There are some configuration parameters in $HOME/.config/darktable/darktablerc that help
      to finetune your system's OpenCL performance. Performance in this context mostly means the
      latency of darktable during interactive work, i.e. how long it takes to reprocess your
      pixelpipe. For a comfortable workflow it is essential to keep latency low.
    </p>
               <p>
      In order to get profiling info you start darktable from a terminal with
    </p>
               <pre>darktable -d opencl -d perf
</pre>
               <p>
      After each reprocessing of pixelpipe – caused by module parameter change,
      zooming, panning, etc. – you will get the total time and the time spent in each
      of our OpenCL kernels. The most reliable value is the total time spent in pixelpipe.
      Please note that the timings given for each individual module are unreliable when running
      the OpenCL pixelpipe asynchronously (see opencl_async_pixelpipe below).
    </p>
               <p>
      To allow for a fast pixelpipe processing with OpenCL it is essential that we keep the GPU
      busy. Any interrupts or a stalled data flow will add to the total processing time. This is
      especially important for the small image buffers we need to handle during interactive
      work. They can be processed quickly by a fast GPU. However, even short-term stalls of the
      pixelpipe will easily become a bottleneck.
    </p>
               <p>
      On the other hand darktable's performance during file exports is more or less only
      governed by the speed of our algorithms and the horse-power of your GPU. Short-term stalls
      will not have a noticeable effect on the total time of an export.
    </p>
               <p>
      darktable comes with default settings that should deliver a decent GPU performance on most
      systems. However, if you want to fiddle around a bit by yourself and try to optimize
      things further, here is a description of the relevant configuration parameters.
      <dl>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_async_pixelpipe</systemoutput>

                        </dt>
                        <dd> This boolean flag controls how often we block the OpenCL pixelpipe and
                           get a status on success/failure of all the kernels that have been run.
                           For optimum latency set this to TRUE, so darktable runs the pixelpipe
                           asynchronously and tries to use as few interrupts as possible. If you
                           experience OpenCL errors like failing kernels, set the parameter to
                           FALSE. darktable will then interrupt after each module so you can more
                           easily isolate the problem. Problems have been reported with some older
                           ATI/AMD cards, like HD57xx, which can produce garbled output if this
                           parameter is set to TRUE. If in doubt, leave it at its default FALSE. </dd>
                     </dlentry>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_number_event_handles</systemoutput>

                        </dt>
                        <dd> Event handles are used so we can monitor success/failure of kernels and
                           profiling info even if the pixelpipe is run asynchronously. The number of
                           event handles is a limited resource of your OpenCL driver. For sure we
                           can recycle them, but there is a limited number that we can use at the
                           same time. Unfortunately, there is no way to find out what the resource
                           limits are; so we need to guess. Our default value of 25 is quite
                           conservative. You might want to try if higher values like 100 give better
                           OpenCL performance. If your driver runs out of free handles you would
                           experience failing OpenCL kernels with error code <q>-5
                              (CL_OUT_OF_RESOURCES)</q> or even crashes or system freezes; reduce
                           the number again in that case. A value of 0 will block darktable from
                           using any event handles. This will prevent darktable from properly
                           monitoring the success of your OpenCL kernels but saves some driver
                           overhead. The consequence is that any failures will likely lead to
                           garbled output without darktable taking notice; only recommended if you
                           know for sure that your system runs rock-solid. You can also set this
                           parameter to -1, which means that darktable assumes no restriction in the
                           number of event handles; this is not recommended. </dd>
                     </dlentry>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_synch_cache</systemoutput>

                        </dt>
                        <dd> This parameter, if set to "true", will force darktable to fetch image
                           buffers from your GPU after each module and store them in its pixelpipe
                           cache. This is a resource consuming operation, but makes sense depending
                           on your GPU (including if the GPU is rather slow). In that case darktable
                           might in fact save some time when module parameters have changed, as it
                           can go back to some cached intermediate state and reprocess only part of
                           the pixelpipe. In many cases this parameter should be set to "active
                           module" (default), which will only cache the input of the currently
                           focused module. </dd>
                     </dlentry>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_micro_nap</systemoutput>

                        </dt>
                        <dd> In an ideal case you keep your GPU busy at 100% when reprocessing the
                           pixelpipe. That's good. On the other hand your GPU is also needed to do
                           regular GUI updates. It might happen that there is no sufficient time
                           left for this task. Consequence would by a jerky reaction of your GUI on
                           panning, zooming or when moving sliders. darktable can add small naps
                           into its pixelpipe processing to have the GPU catch some breath and do
                           GUI related stuff. Parameter opencl_micro_nap controls the duration of
                           these naps in microseconds. You need to experiment in order to find an
                           optimum value for your system. Values of 0, 100, 500 and 1000 are good
                           starting points to try. Defaults to 1000. </dd>
                     </dlentry>
                     <dlentry>
                        <dt>

                           <systemoutput>opencl_use_pinned_memory</systemoutput>

                        </dt>
                        <dd> During tiling huge amounts of memory need to be transferred between
                           host and device. On some devices (namely AMD) direct memory transfers to
                           and from an arbitrary host memory region may give a huge performance
                           penalty. This is especially noticeable when exporting large images.
                           Setting this configuration parameter to TRUE tells darktable to use a
                           special kind of intermediate buffer for host-device data transfers. On
                           some devices this can speed up exporting of large files by a factor of 2
                           to 3. NVIDIA devices and drivers seem to have a more efficient memory
                           transfer technique even for arbitrary memory regions. As they may not
                           show any performance gain and even may produce garbled output,
                           opencl_use_pinned_memory should be left at its default FALSE for those
                           devices. </dd>
                     </dlentry>
                  </dl>
               </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_profiling">
            <title>OpenCL scheduling profile</title>
            <body>
               <p>
      darktable can use the CPU and one or several OpenCL capable GPUs. Depending on the
      relative performance users can choose among certain scheduling profiles to optimize
      performance. This is done by the configuration parameter <q>OpenCL scheduling
      profile</q> in the <q>core options</q> dialog (<xref href="core_options"/>)
      which offers the following choices:
    </p>
               <p>
                  <table frame="none">
                     <tgroup colsep="0" rowsep="0" cols="2">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="3*"/>
                        
                        <tbody>
                           <row>
                              <entry>
                default
              </entry>
                              <entry> If an OpenCL capable GPU is found darktable uses it for
                                 processing the center image view while the preview window (see
                                    <xref href="navigation"/>) is processed on the CPU in
                                 parallel. This is the preferred setting for systems with a
                                 reasonably fast CPU and a moderately fast GPU. The exact allocation
                                 of devices to the various pixelpipe types can be finetuned with the
                                    <q>opencl_device_priority</q> configuration parameter (see
                                 below). </entry>
                           </row>
                           <row>
                              <entry>
                very fast GPU
              </entry>
                              <entry>
                With this scheduling profile darktable processes the center image view and the
                preview window on the GPU sequentially. This is the preferred setting for
                systems with a GPU that strongly outperforms the CPU.
              </entry>
                           </row>
                           <row>
                              <entry>
                multiple GPUs
              </entry>
                              <entry>
                This setting addresses systems with multiple GPUs whose relative performance
                does not differ significantly. Whenever a processing job is started darktable
                uses any currently idle GPU but not the CPU. Users of systems with a variety of
                GPUs will need better control on their relative priority. They should better
                select the <q>default</q> profile and finetune their system with the
                <q>opencl_device_priority</q> configuration parameter (see below).
              </entry>
                           </row>
                        </tbody>
                     </tgroup>
                  </table>
               </p>
               <p> On first start-up or after any detected change in the GPU configuration of your
                  system darktable tries to identify the best suited profile for you. You can change
                  it at any time in the <q>core options</q> dialog (<xref href="core_options"/>)
                  with immediate effect. </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_multiple_devices">
            <title>Multiple OpenCL devices – manual settings</title>
            <body>
               <p>
      The scheduling of OpenCL devices on most typical systems can be optimized using the
      <q>OpenCL scheduling profile</q> settings. However, if your system is equipped
      with a variety of GPUs you might want to set the relative device priority manually. To do
      so you need to select the <q>default</q> scheduling profile and do your settings
      in the <q>opencl_device_priority</q> configuration parameter.
    </p>
               <p>
      It is important to understand how darktable uses OpenCL devices. Each processing sequence
      of an image – to convert an input to the final output using a certain history
      stack – is run in a so called pixelpipe. There are four different types of
      pixelpipe in darktable. One type is responsible to process the center image view (or full
      view) in darkroom mode, another pixelpipe processes the preview image (navigation window)
      top left in darkroom mode. Of each of these two pixelpipe there can be one at a
      time – with the full and the preview pixelpipe running in parallel. In addition
      there can be multiple parallel pixelpipes doing file exports and there can be multiple
      parallel pixelpipes generating thumbnails. If an OpenCL device is available darktable
      dynamically allocates it to one specific pixelpipe for one run and releases it afterwards.
    </p>
               <p>
      The computational demand depends a lot on the pixelpipe type. Preview image and thumbnails
      have a low resolution and can be processed quickly; center image view is more demanding,
      let alone the pixelpipe doing a file export.
    </p>
               <p>
      Configuration parameter <q>opencl_device_priority</q> holds a string with the
      following structure:
    </p>
               <p>
                  <pre>a,b,c.../k,l,m.../o,p,q.../x,y,z...
</pre>
               </p>
               <p>
      Each letter represents one specific OpenCL device. There are four fields in the parameter
      string separated by a slash, each representing one type of pixelpipe.
      <q>a,b,c...</q> defines the devices that are allowed to process the center image
      (full) pixelpipe. Likewise devices <q>k,l,m...</q> can process the preview
      pixelpipe, devices <q>o,p,q...</q> the export pixelpipes and finally devices
      <q>x,y,z...</q> the thumbnail pixelpipes. An empty field means that no OpenCL
      device may serve this type of pixelpipe.
    </p>
               <p>
      darktable has an internal numbering system, where the first available OpenCL device will
      receive number <q>0</q>. All further devices are numbered consecutively. This
      number together with the device name is displayed when you start darktable with
      <q>darktable -d opencl</q>. You can specify a device either by number or by name
      (upper/lower case and whitespace do not matter). If you have more than one
      device – all with the same name – you need to use the device numbers
      in order to differentiate them.
    </p>
               <p>
      A device specifier can be prefixed with an exclamation mark <q>!</q>, in which
      case the device is excluded from processing this pixelpipe. You can also give an asterisk
      <q>*</q> as a wildcard, representing all devices not mentioned explicitly before
      in that group.
    </p>
               <p>
      Sequence order within a group matters. darktable will read the list from left to right and
      whenever it tries to allocate an OpenCL device to a pixelpipe it will scan the devices in
      that order, taking the first free device it finds.
    </p>
               <p>
      If a pixelpipe process is about to be started and if all GPUs in the corresponding group
      are busy, darktable automatically processes the image on the CPU by default. You can
      enforce GPU processing by prefixing the list of allowed GPUs with a plus sign
      <q>+</q>. darktable will not use the CPU but rather suspend processing until the
      next allowed OpenCL device is available.
    </p>
               <p>
      darktable's default setting for <q>opencl_device_priority</q> is:
    </p>
               <pre>*/!0,*/*/*
</pre>
               <p>
      Any detected OpenCL device is allowed to process our center view image. The first OpenCL
      device (0) is not allowed to process the preview pixelpipe. As a consequence, if there is
      only one GPU owned by your system, preview pixelpipe will always be processed on CPU,
      keeping your single GPU exclusively for the more demanding center image view. This is a
      reasonable setting for most systems. No restrictions apply to export and thumbnail
      pixelpipes.
    </p>
               <p>
      The default is a good choice if you have only one device. If you have several devices it
      forms a reasonable starting point. However, as your devices might have quite different
      levels of processing power, it makes sense to invest a few thoughts and optimize your
      priority list.
    </p>
               <p>
      Here is an example. Let's assume we have a system with two devices, a fast Radeon HD7950
      and an older and slower GeForce GTS450. darktable (started with <q>darktable -d
      opencl</q>) will report the following devices:
    </p>
               <pre>[opencl_init] successfully initialized.
[opencl_init] here are the internal numbers and names of
                          OpenCL devices available to darktable:
[opencl_init]           0       'GeForce GTS 450'
[opencl_init]           1       'Tahiti'
[opencl_init] FINALLY: opencl is AVAILABLE on this system.
</pre>
               <p>
      So the GeForce GTS 450 is detected as the first device; the Radeon HD7950 ('Tahiti') as
      the second one. This order will normally not change unless the hardware or driver
      configuration is modified. But it's better to use device names rather than numbers to be
      on the safe side.
    </p>
               <p>
      As the GTS450 is slower than the HD7950, an optimized opencl_device_priority could look
      like:
    </p>
               <pre>!GeForce GTS450,*/!Tahiti,*/Tahiti,*/Tahiti,*
</pre>
               <p>
      The GTS450 is explicitly excluded from doing the center image pixelpipe; this is reserved
      to <q>all</q> other devices (i.e. the HD7950/Tahiti). Completely the opposite for
      our preview pixelpipe. Here the Tahiti is excluded, so that only the GTS450 will be
      allowed to do the work.
    </p>
               <p>
      For file export and thumbnail generation we want all hands on deck. However, darktable
      should first look if device Tahiti is free, because it's faster. If that's not the case,
      all other devices – in fact only the GTS450 – are checked.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_and_opencl_still_fubar">
            <title>OpenCL still does not run for me!</title>
            <body>
               <p>
      As has been said before OpenCL systems come with a huge variety of setups: different GPU
      manufacturers, different GPU models, varying amounts of GPU memory, different drivers,
      different distributions etc. Many of the potential problems will only appear with a very
      specific combination of those factors.
    </p>
               <p>
      As we developers of darktable on our computers only have access to a small fraction of
      those variations, please understand that we might not be able to fix your specific
      problem. There is not much we can do, if there is no way for us to reproduce.
    </p>
               <p>
      If nothing else helps, the best option might be to start darktable with
    </p>
               <pre>darktable --disable-opencl
</pre>
               <p>
      In the end there is nothing in darktable which only runs on GPU. Don't let OpenCL
      discourage you; also darktable's CPU code is highly optimized for performance!
    </p>
            </body>
            
         </topic>
      </topic>
      <topic xml:lang="en-us" id="darktable_chart">
         <title>Using <filepath>darktable-chart</filepath>

         </title>
         
         <prolog>
            <metadata><keywords>
                  <indexterm>darktable-chart</indexterm>
               </keywords></metadata>
            
         </prolog>
         <topic xml:lang="en-us" id="darktable_chart_overview">
            <title>Overview</title>
            <body>
               <p> With <filepath>darktable-chart</filepath> we provide a tool for extracting
                  luminance and color values out of images taken from color reference cards like
                  IT8.7/1 charts. Its main purpose is to compare a source image (typically a largely
                  unprocessed raw image) to a target image (typically a JPEG image created
                  in-camera) and produce a darktable style that is able to convert luminance and
                  color values of the source image to produce the target image. This style employs
                  the <i>tone curve</i> module, the <i>input color profile</i>, and the <i>color
                     look up table</i> module for that purpose (see <xref href="tone_curve"/>,
                     <xref href="input_color_profile"/>, and <xref href="color_look_up_table"
                  />). </p>
               <p>
      Some cameras are particularly advanced in offering various film simulation modes of your
      choice. With the help of <filepath>darktable-chart</filepath> and the underlying modules
      you can now create styles that replicate these film simulations from within darktable.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_chart_usage">
            <title>Usage</title>
            <body>
               <p>
                  <table frame="none">
                     <tgroup colsep="0" rowsep="0" cols="2">
                        <colspec colwidth="6*"/>
                        <colspec colwidth="4*"/>
                        
                        <tbody>
                           <row>
                              <entry>
                The tool is organized into three tabs in the upper part and a text output frame
                in the lower part.
              </entry>
                              <entry>
                                 <image href="../images/darktable_chart_overview.png"
                                        align="center"
                                        placement="break"/>
                              </entry>
                           </row>
                        </tbody>
                     </tgroup>
                  </table>
               </p>
               <p>
      The first tab is used to define the source image, the second tab defines the reference
      (target) and the third tab contains the controls to generate the resulting darktable
      style.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_chart_source_image">
            <title>Source image</title>
            <body>
               <p>
      In the <q>source image</q> tab you set your source image which requires two
      elements. The first element is an input file in Lab Portable Float Map format (extension
      <i>.pfm</i>). The source file represents the largely unmodified data as the
      camera sees them. Details on taking photos of a color reference card and producing a
      <i>.pfm</i> output file are described below. The second element is a chart
      file that contains a formal description of the underlying color reference card's layout
      (extension <i>.cht</i>). Chart files are usually shipped with your color
      reference card or can be downloaded.
    </p>
               <p>
      In real life the photo taken from the color reference card will show some perspective
      distortions relative to the layout defined in the chart file. For that reason the layout
      is displayed as a grid over the image and can be modified.
    </p>
               <p>
                  <table frame="none">
                     <tgroup colsep="0" rowsep="0" cols="2">
                        <colspec colwidth="6*"/>
                        <colspec colwidth="4*"/>
                        
                        <tbody>
                           <row>
                              <entry>
                You can move the corners of the grid using the mouse to reach best alignment of
                grid and image.
              </entry>
                              <entry>
                                 <image href="../images/darktable_chart_source.png"
                                        align="center"
                                        placement="break"/>
                              </entry>
                           </row>
                        </tbody>
                     </tgroup>
                  </table>
               </p>
               <p>
      A rectangular frame is displayed for each patch and defines the area from which
      <filepath>darktable-chart</filepath> will actually sample the needed input data. It may be
      required to modify the size of these rectangles so that the sampling area is big enough
      but does not overlap with neighboring patches. Use the <q>size</q> slider in the
      upper right part of the GUI. Higher values lead to smaller sizes.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_chart_reference_values">
            <title>Reference values</title>
            
            <prolog>
               <metadata><keywords></keywords></metadata>
               
            </prolog>
            <body>
               <p>
      The <q>reference values</q> tab determines the target values to which the source
      image is to be modified by the resulting style. You can either supply reference values in
      the form of measured data of your color reference card (mode <q>cie/it8 file</q>),
      or you supply a photographic image (mode <q>color chart image</q>) much in the
      same way as described above. This second image must also be supplied in Lab Portable Float
      Map format. There is no need to supply the chart file again as
      <filepath>darktable-chart</filepath> takes the same one as defined under <q>source
      image</q>. You only need to again align the layout grid and the image and potentially
      adjust the <q>size</q> slider.
    </p>
               <p>
      In a typical use case the second image will be based on a JPEG file produced in-camera.
      This way you can create a style to simulate the in-camera processing within darktable.
    </p>
               <p>
      In the lower text output frame you see the color values extracted from the available data
      for each individual color patch. The first column gives the name of the patch, the second
      and third column show the corresponding color values of the source image in RGB and Lab
      format, respectively. The fourth column contains the Lab value coming from the reference
      (or from the chart file if no reference image has been given). Finally, the fifth and
      sixth columns display how strongly source and reference values deviate in terms of delta E
      values.
    </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_chart_process">
            <title>Process</title>
            <body>
               <p>
                  <table frame="none">
                     <tgroup colsep="0" rowsep="0" cols="2">
                        <colspec colwidth="6*"/>
                        <colspec colwidth="4*"/>
                        
                        <tbody>
                           <row>
                              <entry>
                If all required settings in <q>source image</q> and <q>reference
                values</q> are ready you can move to the <q>process</q> tab.
              </entry>
                              <entry>
                                 <image href="../images/darktable_chart_process.png"
                                        align="center"
                                        placement="break"/>
                              </entry>
                           </row>
                        </tbody>
                     </tgroup>
                  </table>
               </p>
               <p>
      You first need to tell <filepath>darktable-chart</filepath> which of the patches represent
      the gray ramp. In the screenshot displayed further above the gray ramp is positioned in
      the lower part of the color reference chart, denoted as <q>GS00...GS23</q>.
    </p>
               <p> The input <q>number of final patches</q> defines how many editable color patches
                  the resulting style will use within the <i>color look up table</i> module (for
                  more details see <xref href="color_look_up_table"/>). </p>
               <p>
      By clicking the <q>process</q> button you start the calculation.
    </p>
               <p>
      The quality of the result in terms of average delta E and maximum delta E are displayed
      below the button. These data show how close the resulting style applied to the source
      image will be able to match the reference values – the lower the better.
    </p>
               <p>
                  <table frame="none">
                     <tgroup colsep="0" rowsep="0" cols="2">
                        <colspec colwidth="6*"/>
                        <colspec colwidth="4*"/>
                        
                        <tbody>
                           <row>
                              <entry>
                Once you are happy with the result you can click on <q>export</q> and
                save the generated style.
              </entry>
                              <entry>
                                 <image href="../images/darktable_chart_save.png"
                                        align="center"
                                        placement="break"/>
                              </entry>
                           </row>
                        </tbody>
                     </tgroup>
                  </table>
               </p>
               <p> You supply a style name and a style description under which the style will later
                  appear in darktable. <filepath>darktable-chart</filepath> saves the style as a
                     <i>.dtstyle</i> file which can be imported into darktable (see <xref
                     href="styles"/>) and shared with others. </p>
               <p> The <q>export raw data as csv</q> button allows you to save the extracted raw
                  data as a CSV file for debugging purposes or later usage.
                     <filepath>darktable-chart</filepath> offers a command line option to produce a
                  style with the desired number of final patches from a supplied CSV file (see <xref
                     href="darktable_chart_commandline_parameters"/>). </p>
            </body>
            
         </topic>
         <topic xml:lang="en-us" id="darktable_chart_making_input_images">
            <title>Making input images for <filepath>darktable-chart</filepath>

            </title>
            <body>
               <p>
      To start with, you need a suitable photo of your color reference card in RAW+JPEG format.
      It goes beyond the scope of this manual to explain the details of how to take this photo,
      but in a nutshell you need to make the shot on a sunny day around midday with the light
      source (sun) shining at an angle onto the card. You need to avoid any glare in the image.
      The neutral white color patch in the gray ramp (G00) should end up at the L value
      specified in the description of your card. Often this is L=92 and requires you to
      overexpose the shot by about 1/3 EV. Ideally you make several shots with slightly
      different exposures to later select the right one in darktable. Make sure that the chart
      fills up most of the frame. Take a lens with a <q>normal</q> focal length (e.g.
      50mm equivalent) and stop down a bit to avoid vignetting.
    </p>
               <p> You then open the raw file in darktable and disable most modules, especially
                     <i>base curve</i>. Select the standard input matrix in the <i>input color
                     profile</i> module and disable gamut clipping. Select <q>camera white
                     balance</q> in the <i>white balance</i> module (see <xref href="base_curve"
                  />, <xref href="input_color_profile"/>, and <xref href="whitebalance"/>). </p>
               <p> There is a special situation if your camera automatically applies some lens
                  corrections, namely vignetting correction, to the resulting JPEG file. In this
                  case you need to activate the <i>lens correction</i> module in darktable so that
                  raw processing matches the JPEG in this respect (see <xref
                     href="lens_correction"/>). However, since darktable's vignetting correction
                  may not exactly match the in-camera correction, it's better to disable this
                  correction in the camera if possible. </p>
               <p> To output your image you go to the <q>export</q> module in darktable (see <xref
                     href="export_selected"/>). </p>
               <p>
      You need to select <q>Lab</q> as output color profile. This color space is not
      visible in the combobox by default. You first need to enable it by setting
      allow_lab_output to TRUE in <filepath>$HOME/.config/darktable/darktablerc</filepath>.
      Alternatively, you can start darktable with:
    </p>
               <p>
                  <pre>darktable --conf allow_lab_output=true
</pre>
               </p>
               <p>
      Then select <q>PFM (float)</q> as output format and press <q>export</q> to
      generate the source image file.
    </p>
               <p>
      In a similar way you produce the corresponding reference (target) image from the JPEG.
      Also this time you need to disable all modules and export with <q>Lab</q> output
      color profile in <q>PFM (float)</q> format.
    </p>
            </body>
            
         </topic>
      </topic>
   </topic>
</dita>
